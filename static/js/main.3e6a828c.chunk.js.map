{"version":3,"sources":["components/Node.js","components/Tutorial.js","App.js","index.js"],"names":["Node","row","col","className","Tutorial","useState","arrow","setArrow","onClick","class","App","documentNodes","nodes","currentRow","push","wallToggle","nodeToggle","startToggle","startNode","endNode","endToggle","document","addEventListener","e","key","useEffect","querySelectorAll","forEach","node","classList","add","parcels","length","remove","includes","value","contains","directions","permGraph","Object","create","permArray","endArray","clearBoard","undefined","alert","nodesArray","map","stringifyNodesArray","item","splitter","split","startGraph","endGraph","graph","Number","substring","thisNode","upNode","downNode","leftNode","rightNode","nodeGraph","filter","newGraph","i","keys","findRoute","from","to","array","args","splice","indexOf","work","at","route","place","index","some","w","concat","perm","parentNode","destinationNodes","endPerm","endDestinations","reverse","shortestPath","vertices","s","vertex","minDistance","Infinity","minPath","permutations","inputArr","result","permute","arr","m","curr","slice","next","permutator","currentDistance","currentPath","k","j","tsp","setTimeout","querySelector","pathButton","rowIdx","ReactDOM","render","getElementById"],"mappings":"qPAOeA,MAJf,YAA6B,IAAbC,EAAY,EAAZA,IAAKC,EAAO,EAAPA,IACnB,OAAO,qBAAKC,UAAS,gBAAWF,EAAX,aAAmBC,M,aCA3B,SAASE,IAAY,IAAD,EACPC,oBAAS,GADF,mBAC1BC,EAD0B,KACnBC,EADmB,KAGjC,OACE,sBAAKJ,UAAWG,EAAQ,kBAAoB,gBAA5C,UACE,sBAAKH,UAAU,kBAAf,UACE,oBACEK,QAAS,kBAAMD,GAAUD,IACzBH,UAAWG,EAAQ,WAAa,aAFlC,SAIGA,EACC,sBAAKH,UAAU,OAAf,UACE,mBAAGM,MAAM,gBADX,eAIA,qBAAKN,UAAWG,EAAQ,WAAa,UAArC,SACE,mBAAGG,MAAM,4BAIdH,EAAQ,KACP,qBAAIH,UAAU,wBAAd,UACE,mBAAGM,MAAM,gBADX,kBAKHH,EAAQ,KACP,sBAAKH,UAAU,mBAAf,UACE,+QAMA,uBACA,gCACE,kGACoE,IAClE,mBAAGA,UAAU,yBAEf,uBACA,8BACE,mBAAGM,MAAM,yBADX,0EAIA,8BACE,mBAAGA,MAAM,yBADX,yEAIA,8BACE,mBAAGA,MAAM,yBADX,2EAIA,8BACE,mBAAGA,MAAM,yBADX,mF,MCnDG,SAASC,IAEtB,IADA,IASIC,EATEC,EAAQ,GACLX,EAAM,EAAGA,EAAM,GAAIA,IAAO,CAEjC,IADA,IAAMY,EAAa,GACVX,EAAM,EAAGA,EAAM,GAAIA,IAC1BW,EAAWC,MAAK,GAElBF,EAAME,KAAKD,GAIb,IAAIE,EACFC,EACAC,EAwEEC,EACAC,EAxEFC,GAAY,EAEdC,SAASC,iBAAiB,WAAW,SAACC,GACpC,OAAQA,EAAEC,KACR,IAAK,IACHT,GAAa,EACbC,GAAa,EACbC,GAAc,EACdG,GAAY,EACZ,MACF,IAAK,IACHL,GAAa,EACbC,GAAa,EACbC,GAAc,EACdG,GAAY,EACZ,MACF,IAAK,IACHL,GAAa,EACbC,GAAa,EACbC,GAAc,EACdG,GAAY,EACZ,MACF,IAAK,IACHL,GAAa,EACbC,GAAa,EACbC,GAAc,EACdG,GAAY,MAOlBC,SAASC,iBAAiB,SAAS,SAACC,GAClCR,GAAa,KAGfU,qBAAU,YACRd,EAAgBU,SAASK,iBAAiB,UAC5BC,SAAQ,SAACC,GACrBA,EAAKN,iBAAiB,aAAa,WAC7BP,GAAYa,EAAKC,UAAUC,IAAI,WAErCF,EAAKN,iBAAiB,SAAS,WACzBN,GAAce,EAAQC,QAAU,IAClCJ,EAAKC,UAAUI,OAAO,WACtBL,EAAKC,UAAUC,IAAI,YACdC,EAAQG,SAASN,IAASA,EAAKC,UAAUM,MAAMD,SAAS,SAC3DH,EAAQjB,KAAKc,IAEbX,IACFN,EAAcgB,SAAQ,SAACC,GACjBA,EAAKC,UAAUO,SAAS,eAC1BR,EAAKC,UAAUI,OAAO,iBAE1BL,EAAKC,UAAUC,IAAI,cACnBZ,EAAYU,GAGVR,IACFT,EAAcgB,SAAQ,SAACC,GACjBA,EAAKC,UAAUO,SAAS,aAC1BR,EAAKC,UAAUI,OAAO,eAE1BL,EAAKC,UAAUC,IAAI,YACnBX,EAAUS,YAWlB,IAAIG,EAAU,GACVM,EAAa,GAEbC,EAAYC,OAAOC,OAAO,MAC1BC,EAAY,GACZC,EAAW,GA6OTC,EAAa,WACjBhC,EAAcgB,SAAQ,SAACC,GACjBA,EAAKC,UAAUG,QAAU,GAC3BJ,EAAKC,UAAUI,OACb,SACA,OACA,aACA,WACA,OACA,UACA,YAGNf,OAAY0B,EACZzB,OAAUyB,EAGVb,EAAU,GACVM,EAAa,GAEbC,EAAYC,OAAOC,OAAO,MAC1BC,EAAY,GACZC,EAAW,IAGb,OACE,sBAAKvC,UAAU,OAAf,UACE,sBAAKA,UAAU,SAAf,UACE,oBAAIK,QAAS,kBAvQA,WACjB,QAAkBoC,IAAd1B,QAAuC0B,IAAZzB,GAAyBY,EAAQC,OAAS,EACvEa,MAAM,sEACH,CACH,IAAMC,EAAa,YAAInC,GAAeoC,KAAI,SAACnB,GAAD,OAAUA,EAAKC,aACnDmB,EAAsB,YAAIrC,GAAeoC,KAAI,SAACE,GAClD,IAAKA,EAAKpB,UAAUM,MAAMD,SAAS,QAAS,CAC1C,IAAIgB,EAAWD,EAAKpB,UAAUM,MAAMgB,MAAM,KAC1C,MAAM,GAAN,OAAUD,EAAS,GAAnB,YAAyBA,EAAS,GAAlC,YAAwCA,EAAS,IAEnD,OAAOD,EAAKpB,UAAUM,SAEpBiB,EAAalC,EAAUW,UAAUM,MAAMgB,MAAM,KACjDC,EAAU,WAAOA,EAAW,GAAlB,YAAwBA,EAAW,GAAnC,YAAyCA,EAAW,IAC9D,IAAIC,EAAWlC,EAAQU,UAAUM,MAAMgB,MAAM,KAC7CE,EAAQ,WAAOA,EAAS,GAAhB,YAAsBA,EAAS,GAA/B,YAAqCA,EAAS,IAoCtD,IAlCA,IAAMC,EAAQR,EAAWC,KAAI,SAACnB,GAC5B,IAAM3B,EAAMsD,OAAO3B,EAAK,GAAG4B,UAAU,IAC/BtD,EAAMqD,OAAO3B,EAAK,GAAG4B,UAAU,IAE/BC,EAAQ,iBAAaxD,EAAb,aAAqBC,GAE7BwD,EAASV,EAAoBd,SAApB,gBAAsCjC,EAAM,EAA5C,aAAkDC,IAAlD,iBACDD,EAAM,EADL,aACWC,GACtB,KACEyD,EAAWX,EAAoBd,SAApB,gBACNjC,EAAM,EADA,aACMC,IADN,iBAGHD,EAAM,EAHH,aAGSC,GACtB,KACE0D,EAAWZ,EAAoBd,SAApB,gBACNjC,EADM,aACEC,EAAM,IADR,iBAGHD,EAHG,aAGKC,EAAM,GACxB,KACE2D,EAAYb,EAAoBd,SAApB,gBACPjC,EADO,aACCC,EAAM,IADP,iBAGJD,EAHI,aAGIC,EAAM,GACxB,KAEA4D,EAAYvB,OAAOC,OAAO,MAK9B,OAJAsB,EAAUL,GAAY,CAACC,EAAQC,EAAUC,EAAUC,GAAWE,QAC5D,SAACd,GAAD,OAAkB,MAARA,KAGLa,KAGLE,EAAWzB,OAAOC,OAAO,MACpByB,EAAI,EAAGA,EAAIX,EAAMtB,OAAQiC,IAChCD,EAASzB,OAAO2B,KAAKZ,EAAMW,IAAI,IAAMX,EAAMW,GAAG1B,OAAO2B,KAAKZ,EAAMW,IAAI,IAjDnE,oBAoDgBlC,GApDhB,IAoDH,2BAA4B,CAAC,IACvBkB,EADsB,QACRpB,UAAUM,MAAMgB,MAAM,KACxCd,EAAWvB,KAAX,WAAoBmC,EAAK,GAAzB,YAA+BA,EAAK,GAApC,YAA0CA,EAAK,MAtD9C,8BAsHH,IAAMkB,EAAY,SAAZA,EAAab,EAAOc,EAAMC,EAAIC,EAAOC,GACzC,GAAkB,IAAdF,EAAGrC,OAGL,OAFAsC,EAAME,OAAOF,EAAMG,QAAQL,GAAO,EAAG,QACrC3B,EAAU3B,KAAKwD,GAIjB,IADA,IAAII,EAAO,CAAC,CAAEC,GAAIP,EAAMQ,MAAO,KACtBX,EAAI,EAAGA,EAAIS,EAAK1C,OAAQiC,IAAK,CAAC,IAAD,IAChBS,EAAKT,GAAnBU,EAD8B,EAC9BA,GAAIC,EAD0B,EAC1BA,MAD0B,cAElBtB,EAAMqB,IAFY,yBAE3BE,EAF2B,QAGlC,GAAIR,EAAGnC,SAAS2C,GAAQ,CACtBP,EAAME,OAAOF,EAAMG,QAAQI,GAAQ,EAAG,CACpCD,EACAA,EAAM5C,OACN6C,IAEF,IAAIC,EAAQT,EAAGI,QAAQI,GACvBR,EAAGG,OAAOM,EAAO,GACjBX,EAAUb,EAAOc,EAAMC,EAAIC,GAExBI,EAAKK,MAAK,SAACC,GAAD,OAAOA,EAAEL,IAAME,MAC5BH,EAAK5D,KAAK,CAAE6D,GAAIE,EAAOD,MAAOA,EAAMK,OAAOJ,MAZ/C,2BAA8B,IAFM,iCAoBpCK,EAAO7C,EAAWU,KAAI,SAACE,GAAD,OAAUA,KACpCiC,EAAI,CAAI9B,GAAJ,mBAAmB8B,IACvB,IAnJG,eAmJMjB,GACP3B,EAAU4C,EAAKjB,IAAMiB,EACrB,IAAIC,EAAaD,EAAKjB,GAClBmB,EAAmBF,EACpBnC,KAAI,SAACE,GAAD,OAAUA,GAAQkC,GAAclC,KACpCc,QAAO,SAACnC,GAAD,OAAkB,GAARA,KAChBa,EAAYyC,EAAKnC,KAAI,SAACE,GAAD,OAAUA,KACnCkB,EAAUH,EAAUmB,EAAYC,EAAkB3C,IAP3CwB,EAAI,EAAGA,EAAIiB,EAAKlD,OAAQiC,IAAM,EAA9BA,GAUT,IAAIoB,EAAUhD,EAAWU,KAAI,SAACE,GAAD,OAAUA,KAEnCqC,GADJD,EAAO,CAAIhC,GAAJ,mBAAiBgC,KAErBtC,KAAI,SAACE,GAAD,OAAUA,GAAQI,GAAYJ,KAClCc,QAAO,SAACnC,GAAD,OAAkB,GAARA,KACpBc,EAAW2C,EAAQtC,KAAI,SAACE,GAAD,OAAUA,KACjCkB,EAAUH,EAAUX,EAAUiC,EAAiB5C,GAEtB,IAArBD,EAAUT,QACZa,MAAM,wCACNF,KACM,WAAD,sBACaF,EAAUA,EAAUT,OAAS,IAD1C,IACL,2BAAmD,CAAC,IAA3CsC,EAA0C,QACpC,GAATA,GAAYA,EAAM,GAAGiB,WAFtB,8BAuDL,IAlDA,IA+CIC,GAAe,MAAGP,OAAH,oBA3BP,SAACQ,EAAUC,EAAGpC,GAExB,IADA,IAAMqC,EAAS,GACN1B,EAAI,EAAGA,EAAIwB,EAAUxB,IACxBA,GAAKyB,GAAGC,EAAO7E,KAAKmD,GAE1B,IALkC,EAK9B2B,EAAcC,IACdC,EAAU,GACVC,EA3Ba,SAACC,GAClB,IAAIC,EAAS,GAgBb,OAdgB,SAAVC,EAAWC,GAAiB,IAAZC,EAAW,uDAAP,GACxB,GAAmB,IAAfD,EAAInE,OACNiE,EAAOnF,KAAKsF,QAEZ,IAAK,IAAInC,EAAI,EAAGA,EAAIkC,EAAInE,OAAQiC,IAAK,CACnC,IAAIoC,EAAOF,EAAIG,QACXC,EAAOF,EAAK7B,OAAOP,EAAG,GAC1BiC,EAAQG,EAAKC,QAASF,EAAEnB,OAAOsB,KAKrCL,CAAQF,GAEDC,EAUYO,CAAWb,GAPI,cAQpBI,GARoB,IAQlC,2BAA4B,CAAC,IAAD,EAAnB9B,EAAmB,QACtBwC,EAAkB,EAClBC,EAAc,GACdC,EAAIjB,EAHkB,cAIZzB,GAJY,IAI1B,2BAAiB,CAAC,IAAT2C,EAAQ,QACfH,GAAmBnD,EAAMqD,GAAGC,GAAG,GAC/BF,EAAY5F,KAAKwC,EAAMqD,GAAGC,GAAG,IAC7BD,EAAIC,GAPoB,8BAS1BH,GAAmBnD,EAAMA,EAAMtB,OAAS,GAAG2E,GAAG,GAC9CD,EAAY5F,KAAKwC,EAAMA,EAAMtB,OAAS,GAAG2E,GAAG,IACxCF,EAAkBb,IACpBA,EAAca,EACdX,EAAUY,IArBoB,8BAwBlC,OAAOZ,EAIJe,CAAIpE,EAAUT,OAAS,EAAG,EAAGS,KArD7B,WAuDImE,GACPE,YAAW,WACTzF,SAAS0F,cAAT,UAA0BvB,EAAaoB,KAAM/E,UAAUC,IAAI,WAC1D,GAAK8E,IAHDA,EAAI,EAAGA,EAAIpB,EAAaxD,OAAQ4E,IAAM,EAAtCA,GAvDH,IA4FaI,IAAnB,uBACA,oBAAIxG,QAAS,kBAAMmC,KAAnB,yBACA,sBAAKxC,UAAU,eAAf,UACE,qBAAKA,UAAU,yBACf,0CAEF,sBAAKA,UAAU,aAAf,UACE,qBAAKA,UAAU,uBACf,wCAEF,sBAAKA,UAAU,cAAf,UACE,qBAAKA,UAAU,wBACf,yCAEF,sBAAKA,UAAU,gBAAf,UACE,qBAAKA,UAAU,0BACf,2CAEF,sBAAKA,UAAU,cAAf,UACE,qBAAKA,UAAU,wBACf,4CAGJ,qBAAKA,UAAU,QAAf,SACGS,EAAMmC,KAAI,SAAC9C,EAAK6E,GACf,IAAImC,EAASnC,EACb,OACE,qBAAK3E,UAAU,MAAf,SACGF,EAAI8C,KAAI,SAAC7C,EAAK4E,GACb,OAAO,cAAC,EAAD,CAA4B7E,IAAKgH,EAAQ/G,IAAK4E,GAA1BA,OAFLA,QAQhC,cAAC,EAAD,OC7YNoC,IAASC,OAAO,cAAC,EAAD,IAAS9F,SAAS+F,eAAe,W","file":"static/js/main.3e6a828c.chunk.js","sourcesContent":["import React from 'react';\nimport './Node.scss';\n\nfunction Node({ row, col }) {\n  return <div className={`node R${row} C${col}`}></div>;\n}\n\nexport default Node;\n","import React from 'react';\nimport { useState } from 'react';\nimport './Tutorial.scss';\n\nexport default function Tutorial() {\n  const [arrow, setArrow] = useState(true);\n\n  return (\n    <div className={arrow ? 'tutorial-closed' : 'tutorial-open'}>\n      <div className=\"tutorial-opener\">\n        <h1\n          onClick={() => setArrow(!arrow)}\n          className={arrow ? 'arrow-up' : 'arrow-down'}\n        >\n          {arrow ? (\n            <div className=\"roto\">\n              <i class=\"fas fa-book\"></i> Tutorial\n            </div>\n          ) : (\n            <div className={arrow ? 'fade-out' : 'fade-in'}>\n              <i class=\"far fa-times-circle\"></i>\n            </div>\n          )}\n        </h1>\n        {arrow ? null : (\n          <h1 className=\"tutorial-opener-words\">\n            <i class=\"fas fa-book\"></i> Tutorial\n          </h1>\n        )}\n      </div>\n      {arrow ? null : (\n        <div className=\"tutorial-content\">\n          <p>\n            The purpose of this application is to find the shortest path between\n            a starting and an ending point with optional detours along the way.\n            The user may also place walls along the grid that will need to be\n            traversed to reach the destination.\n          </p>\n          <br />\n          <div>\n            <p>\n              Please use this application in fullscreen for the best experience{' '}\n              <i className=\"far fa-smile-beam\"></i>\n            </p>\n            <br />\n            <p>\n              <i class=\"fas fa-chevron-right\"></i> To place a start node: click\n              the \"s\" key and click on a grid square\n            </p>\n            <p>\n              <i class=\"fas fa-chevron-right\"></i> To place an end node: click\n              the \"e\" key and click on a grid square\n            </p>\n            <p>\n              <i class=\"fas fa-chevron-right\"></i> To place a detour node: click\n              the \"d\" key and click on a grid square\n            </p>\n            <p>\n              <i class=\"fas fa-chevron-right\"></i> To place a wall node: hold\n              the \"w\" key and hover over a grid square\n            </p>\n          </div>\n        </div>\n      )}\n    </div>\n  );\n}\n","import React from 'react';\nimport Node from './components/Node';\nimport Tutorial from './components/Tutorial';\nimport { useEffect } from 'react';\nimport './App.scss';\n\nexport default function App() {\n  const nodes = [];\n  for (let row = 0; row < 23; row++) {\n    const currentRow = [];\n    for (let col = 0; col < 50; col++) {\n      currentRow.push(true);\n    }\n    nodes.push(currentRow);\n  }\n\n  let documentNodes;\n  let wallToggle,\n    nodeToggle,\n    startToggle,\n    endToggle = false;\n\n  document.addEventListener('keydown', (e) => {\n    switch (e.key) {\n      case 'w':\n        wallToggle = true;\n        nodeToggle = false;\n        startToggle = false;\n        endToggle = false;\n        break;\n      case 'd':\n        wallToggle = false;\n        nodeToggle = true;\n        startToggle = false;\n        endToggle = false;\n        break;\n      case 's':\n        wallToggle = false;\n        nodeToggle = false;\n        startToggle = true;\n        endToggle = false;\n        break;\n      case 'e':\n        wallToggle = false;\n        nodeToggle = false;\n        startToggle = false;\n        endToggle = true;\n        break;\n      default:\n        break;\n    }\n  });\n\n  document.addEventListener('keyup', (e) => {\n    wallToggle = false;\n  });\n\n  useEffect(() => {\n    documentNodes = document.querySelectorAll('.node');\n    documentNodes.forEach((node) => {\n      node.addEventListener('mouseover', () => {\n        if (wallToggle) node.classList.add('wall');\n      });\n      node.addEventListener('click', () => {\n        if (nodeToggle && parcels.length <= 5) {\n          node.classList.remove('address');\n          node.classList.add('address');\n          if (!parcels.includes(node) && node.classList.value.includes('node'))\n            parcels.push(node);\n        }\n        if (startToggle) {\n          documentNodes.forEach((node) => {\n            if (node.classList.contains('start-node'))\n              node.classList.remove('start-node');\n          });\n          node.classList.add('start-node');\n          startNode = node;\n        }\n\n        if (endToggle) {\n          documentNodes.forEach((node) => {\n            if (node.classList.contains('end-node'))\n              node.classList.remove('end-node');\n          });\n          node.classList.add('end-node');\n          endNode = node;\n        }\n      });\n    });\n  });\n\n  let startNode;\n  let endNode;\n  // let endSearch;\n  // let searchTime = 0;\n  // let routeTime = 0;\n  let parcels = [];\n  let directions = [];\n  // let trigger = false;\n  let permGraph = Object.create(null);\n  let permArray = [];\n  let endArray = [];\n\n  const pathButton = () => {\n    if (startNode === undefined || endNode === undefined || parcels.length < 1)\n      alert('Select a start node, an end node, and at least one detour node');\n    else {\n      const nodesArray = [...documentNodes].map((node) => node.classList);\n      const stringifyNodesArray = [...documentNodes].map((item) => {\n        if (!item.classList.value.includes('wall')) {\n          let splitter = item.classList.value.split(' ');\n          return `${splitter[0]} ${splitter[1]} ${splitter[2]}`;\n        }\n        return item.classList.value;\n      });\n      let startGraph = startNode.classList.value.split(' ');\n      startGraph = `.${startGraph[0]}.${startGraph[1]}.${startGraph[2]}`;\n      let endGraph = endNode.classList.value.split(' ');\n      endGraph = `.${endGraph[0]}.${endGraph[1]}.${endGraph[2]}`;\n\n      const graph = nodesArray.map((node) => {\n        const row = Number(node[1].substring(1));\n        const col = Number(node[2].substring(1));\n\n        const thisNode = `.node.R${row}.C${col}`;\n\n        const upNode = stringifyNodesArray.includes(`node R${row - 1} C${col}`)\n          ? `.node.R${row - 1}.C${col}`\n          : null;\n        const downNode = stringifyNodesArray.includes(\n          `node R${row + 1} C${col}`\n        )\n          ? `.node.R${row + 1}.C${col}`\n          : null;\n        const leftNode = stringifyNodesArray.includes(\n          `node R${row} C${col - 1}`\n        )\n          ? `.node.R${row}.C${col - 1}`\n          : null;\n        const rightNode = stringifyNodesArray.includes(\n          `node R${row} C${col + 1}`\n        )\n          ? `.node.R${row}.C${col + 1}`\n          : null;\n\n        let nodeGraph = Object.create(null);\n        nodeGraph[thisNode] = [upNode, downNode, leftNode, rightNode].filter(\n          (item) => item != null\n        );\n\n        return nodeGraph;\n      });\n\n      let newGraph = Object.create(null);\n      for (let i = 0; i < graph.length; i++) {\n        newGraph[Object.keys(graph[i])[0]] = graph[i][Object.keys(graph[i])[0]];\n      }\n\n      for (let parcel of parcels) {\n        let item = parcel.classList.value.split(' ');\n        directions.push(`.${item[0]}.${item[1]}.${item[2]}`);\n      }\n\n      // // ----------------------------------------------------------\n\n      // function findRoute(graph, from, to) {\n      //   documentNodes.forEach((node) => {\n      //     if (node.classList.contains('travel')) {\n      //       node.classList.remove('travel');\n      //       node.classList.add('nomo');\n      //     }\n      //   });\n      //   if (to.length === 0 && !trigger) {\n      //     endSearch = from;\n      //     triggerEndNode();\n      //     return;\n      //   } else if (to.length === 0 && trigger) {\n      //     return;\n      //   }\n      //   let work = [{ at: from, route: [] }];\n      //   for (let i = 0; i < work.length; i++) {\n      //     searchTime = 4 * i;\n      //     setTimeout(() => {\n      //       document.querySelector(`${work[i].at}`).classList.add('travel');\n      //     }, searchTime);\n      //     let { at, route } = work[i];\n      //     for (let place of graph[at]) {\n      //       if (to.includes(place)) {\n      //         let index = to.indexOf(place);\n      //         let pop = to.splice(index, 1);\n      //         for (let j = 0; j < route.length; j++) {\n      //           routeTime = searchTime;\n      //           setTimeout(() => {\n      //             document.querySelector(`${route[j]}`).classList.add('route');\n      //           }, 60 * j + searchTime);\n      //           routeTime += 60 * j;\n      //         }\n      //         return setTimeout(() => {\n      //           findRoute(graph, pop, to);\n      //         }, routeTime);\n      //       }\n      //       if (!work.some((w) => w.at == place)) {\n      //         work.push({ at: place, route: route.concat(place) });\n      //       }\n      //     }\n      //   }\n      // }\n\n      // // ----------------------------------------------------------\n\n      // // ----------------------------------------------------------------------------\n      // const triggerEndNode = () => {\n      //   trigger = true;\n      //   findRoute(newGraph, endSearch[0], [endGraph]);\n      // };\n\n      // if (parcels.length > 0) findRoute(newGraph, startGraph, directions);\n      // else {\n      //   trigger = true;\n      //   findRoute(newGraph, startGraph, [endGraph]);\n      // }\n\n      // ----------------------------------------------------------------------------\n\n      const findRoute = (graph, from, to, array, args) => {\n        if (to.length === 0) {\n          array.splice(array.indexOf(from), 1, 0);\n          permArray.push(array);\n          return;\n        }\n        let work = [{ at: from, route: [] }];\n        for (let i = 0; i < work.length; i++) {\n          let { at, route } = work[i];\n          for (let place of graph[at]) {\n            if (to.includes(place)) {\n              array.splice(array.indexOf(place), 1, [\n                route,\n                route.length,\n                place,\n              ]);\n              let index = to.indexOf(place);\n              to.splice(index, 1);\n              findRoute(graph, from, to, array);\n            }\n            if (!work.some((w) => w.at == place)) {\n              work.push({ at: place, route: route.concat(place) });\n            }\n          }\n        }\n      };\n\n      let perm = directions.map((item) => item);\n      perm = [startGraph, ...perm];\n      for (let i = 0; i < perm.length; i++) {\n        permGraph[perm[i]] = perm;\n        let parentNode = perm[i];\n        let destinationNodes = perm\n          .map((item) => item != parentNode && item)\n          .filter((node) => node != false);\n        let permArray = perm.map((item) => item);\n        findRoute(newGraph, parentNode, destinationNodes, permArray);\n      }\n\n      let endPerm = directions.map((item) => item);\n      endPerm = [endGraph, ...endPerm];\n      let endDestinations = endPerm\n        .map((item) => item != endGraph && item)\n        .filter((node) => node != false);\n      endArray = endPerm.map((item) => item);\n      findRoute(newGraph, endGraph, endDestinations, endArray);\n\n      if (permArray.length === 0) {\n        alert('No possible path\\nResetting board...');\n        clearBoard();\n      } else {\n        for (let array of permArray[permArray.length - 1]) {\n          if (array != 0) array[0].reverse();\n        }\n\n        const permutator = (inputArr) => {\n          let result = [];\n\n          const permute = (arr, m = []) => {\n            if (arr.length === 0) {\n              result.push(m);\n            } else {\n              for (let i = 0; i < arr.length; i++) {\n                let curr = arr.slice();\n                let next = curr.splice(i, 1);\n                permute(curr.slice(), m.concat(next));\n              }\n            }\n          };\n\n          permute(inputArr);\n\n          return result;\n        };\n\n        const tsp = (vertices, s, graph) => {\n          const vertex = [];\n          for (let i = 0; i < vertices; i++) {\n            if (i != s) vertex.push(i);\n          }\n          let minDistance = Infinity;\n          let minPath = [];\n          let permutations = permutator(vertex);\n          for (let i of permutations) {\n            let currentDistance = 0;\n            let currentPath = [];\n            let k = s;\n            for (let j of i) {\n              currentDistance += graph[k][j][1];\n              currentPath.push(graph[k][j][0]);\n              k = j;\n            }\n            currentDistance += graph[graph.length - 1][k][1];\n            currentPath.push(graph[graph.length - 1][k][0]);\n            if (currentDistance < minDistance) {\n              minDistance = currentDistance;\n              minPath = currentPath;\n            }\n          }\n          return minPath;\n        };\n\n        let shortestPath = [].concat(\n          ...tsp(permArray.length - 1, 0, permArray)\n        );\n        for (let j = 0; j < shortestPath.length; j++) {\n          setTimeout(() => {\n            document.querySelector(`${shortestPath[j]}`).classList.add('route');\n          }, 60 * j);\n        }\n      }\n    }\n  };\n\n  const clearBoard = () => {\n    documentNodes.forEach((node) => {\n      if (node.classList.length >= 3)\n        node.classList.remove(\n          'travel',\n          'nomo',\n          'start-node',\n          'end-node',\n          'wall',\n          'address',\n          'route'\n        );\n    });\n    startNode = undefined;\n    endNode = undefined;\n    // searchTime = 0;\n    // routeTime = 0;\n    parcels = [];\n    directions = [];\n    // trigger = false;\n    permGraph = Object.create(null);\n    permArray = [];\n    endArray = [];\n  };\n\n  return (\n    <div className=\"main\">\n      <div className=\"navbar\">\n        <h2 onClick={() => pathButton()}>Find Path</h2>\n        <h2 onClick={() => clearBoard()}>Clear Board</h2>\n        <div className=\"start-legend\">\n          <div className=\"start-legend-graphic\"></div>\n          <h3>Start</h3>\n        </div>\n        <div className=\"end-legend\">\n          <div className=\"end-legend-graphic\"></div>\n          <h3>End</h3>\n        </div>\n        <div className=\"wall-legend\">\n          <div className=\"wall-legend-graphic\"></div>\n          <h3>Wall</h3>\n        </div>\n        <div className=\"detour-legend\">\n          <div className=\"detour-legend-graphic\"></div>\n          <h3>Detour</h3>\n        </div>\n        <div className=\"path-legend\">\n          <div className=\"path-legend-graphic\"></div>\n          <h3>Path</h3>\n        </div>\n      </div>\n      <div className=\"nodes\">\n        {nodes.map((row, index) => {\n          let rowIdx = index;\n          return (\n            <div className=\"row\" key={index}>\n              {row.map((col, index) => {\n                return <Node key={(rowIdx, index)} row={rowIdx} col={index} />;\n              })}\n            </div>\n          );\n        })}\n      </div>\n      <Tutorial />\n    </div>\n  );\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(<App />, document.getElementById('root'));\n"],"sourceRoot":""}